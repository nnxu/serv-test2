// XMega65 Kernal Development Template
// Each function of the kernal is a no-args function
// The functions are placed in the SYSCALLS table surrounded by JMP and NOP

import "string"

#pragma link("mega65hyper.ld")

const char* RASTER = 0xd012;
const char* VIC_MEMORY = 0xd018;
const char* SCREEN = 0x0400;
const char* BGCOL = 0xd021;
const char* COLS = 0xd800;
const char BLACK = 0;
const char BLUE = 6;
const char WHITE = 1;

// Some text to display

char[] MESSAGE = "checkpoint 2.3 by gao0204";

void main() {
}

void reset() {
// Initialize screen memory, and select correct font
     *VIC_MEMORY = 0x14;
     // Fill the screen with spaces
     memset(SCREEN, ' ', 40*25);
     // Set the colour of every character on the screen to white
     memset(COLS, WHITE, 40*25);
     // Print the "checkpoint 1.1 by gao0204" message
     char* sc = SCREEN+40; // Display it one line down on the screen
     char* msg = MESSAGE; // The message to display
     // A simple copy routine to copy the string
     while(*msg) {
         *sc++ = *msg++;
     }
     // Loop forever showing two white lines as raster bars
     while(true) {
         if(*RASTER==54 || *RASTER==66) {
             *BGCOL = WHITE;
         } else {
             *BGCOL = BLUE;
         }
     }
    exit_hypervisor();
}

// Here are a couple sample SYSCALL handlers that just display a character on the screen

void syscall00(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall01() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall02(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall03() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall04(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall05() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall06(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall07() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall08(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall09() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall0A(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall0B() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall0C(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall0D() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall0E(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall0F(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall10() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void securentr(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void securexit() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall13(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall14() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall15(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall16() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall17(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall18() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall19(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall1A() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall1B(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall1C() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall1D(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall1E(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall1F() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall20(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall21() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall22(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall23() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall24(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall25() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall26(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall27() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall28(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall29() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall2A(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall2B() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall2C(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall2D(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall2E() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall2F(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall30() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall31(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall32() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall33(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall34() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall35(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall36() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall37(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall38() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall39(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall3A() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall3B(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall3C(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall3D() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void syscall3E(){
    *(SCREEN+79) = '>';
    exit_hypervisor();
}

void syscall3F() {
    *(SCREEN+78) = '<';
    exit_hypervisor();
}

void pagfault() {
    exit_hypervisor();
}

void restorkey() {
    exit_hypervisor();
}

void alttabkey() {
    exit_hypervisor();
}

void vf011rd() {
    exit_hypervisor();
}

void vf011wr() {
    exit_hypervisor();
}

void reserved() {
    exit_hypervisor();
}

void cpukil() {
    exit_hypervisor();
}

void exit_hypervisor() {
     // Trigger exit from Hypervisor mode
     *(unsigned char *)$D67F = $01;
}

// Now we select the SYSCALL segment to hold the SYSCALL/trap entry point table.

#pragma data_seg(Syscall)

// The structure of each entry point is JMP <handler address> + NOP.
// We have a char (xjmp) to hold the opcode for the JMP instruction,
// and then put the address of the SYSCALL/trap handler in the next
// two points as a pointer, and end with the NOP instruction opcode.

struct SysCall {
    char xjmp;       // Holds $4C, the JMP $nnnn opcode
    void()* syscall; // Holds handler address, will be the target of the JMP
    char xnop;       // Holds $EA, the NOP opcode
};

// To save writing 0x4C and 0xEA all the time, we define them as constants
const char JMP = 0x4c;
const char NOP = 0xea;

// Now we can have a nice table of up to 64 SYSCALL handlers expressed
// in a fairly readable and easy format.
// Each line is an instance of the struct SysCall from above, with the JMP
// opcode value, the address of the handler routine and the NOP opcode value.
export struct SysCall[] SYSCALLS = {
     { JMP, &syscall00, NOP },
     { JMP, &syscall01, NOP },
     { JMP, &syscall02, NOP },
     { JMP, &syscall03, NOP },
     { JMP, &syscall04, NOP },
     { JMP, &syscall05, NOP },
     { JMP, &syscall06, NOP },
     { JMP, &syscall07, NOP },
     { JMP, &syscall08, NOP },
     { JMP, &syscall09, NOP },
     { JMP, &syscall0A, NOP },
     { JMP, &syscall0B, NOP },
     { JMP, &syscall0C, NOP },
     { JMP, &syscall0D, NOP },
     { JMP, &syscall0E, NOP },
     { JMP, &syscall0F, NOP },
     { JMP, &syscall10, NOP },
     { JMP, &securentr, NOP },
     { JMP, &securexit, NOP },
     { JMP, &syscall13, NOP },
     { JMP, &syscall14, NOP },
     { JMP, &syscall15, NOP },
     { JMP, &syscall16, NOP },
     { JMP, &syscall17, NOP },
     { JMP, &syscall18, NOP },
     { JMP, &syscall19, NOP },
     { JMP, &syscall1A, NOP },
     { JMP, &syscall1B, NOP },
     { JMP, &syscall1C, NOP },
     { JMP, &syscall1D, NOP },
     { JMP, &syscall1E, NOP },
     { JMP, &syscall1F, NOP },
     { JMP, &syscall20, NOP },
     { JMP, &syscall21, NOP },
     { JMP, &syscall22, NOP },
     { JMP, &syscall23, NOP },
     { JMP, &syscall24, NOP },
     { JMP, &syscall25, NOP },
     { JMP, &syscall26, NOP },
     { JMP, &syscall27, NOP },
     { JMP, &syscall28, NOP },
     { JMP, &syscall29, NOP },
     { JMP, &syscall2A, NOP },
     { JMP, &syscall2B, NOP },
     { JMP, &syscall2C, NOP },
     { JMP, &syscall2D, NOP },
     { JMP, &syscall2E, NOP },
     { JMP, &syscall2F, NOP },
     { JMP, &syscall30, NOP },
     { JMP, &syscall31, NOP },
     { JMP, &syscall32, NOP },
     { JMP, &syscall33, NOP },
     { JMP, &syscall34, NOP },
     { JMP, &syscall35, NOP },
     { JMP, &syscall36, NOP },
     { JMP, &syscall37, NOP },
     { JMP, &syscall38, NOP },
     { JMP, &syscall39, NOP },
     { JMP, &syscall3A, NOP },
     { JMP, &syscall3B, NOP },
     { JMP, &syscall3C, NOP },
     { JMP, &syscall3D, NOP },
     { JMP, &syscall3E, NOP },
     { JMP, &syscall3F, NOP }
    };

// In this example we had only two SYSCALLs defined, so rather than having
// another 62 lines, we can just ask KickC to make the TRAP table begin
// at the next multiple of $100, i,e., at $8100.
export align(0x100) struct SysCall[] TRAPS = {
    { JMP, &reset, NOP },
    { JMP, &pagfault, NOP },
    { JMP, &restorkey, NOP },
    { JMP, &alttabkey, NOP },
    { JMP, &vf011rd, NOP },
    { JMP, &vf011wr, NOP },
    { JMP, &cpukil, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP },
    { JMP, &reserved, NOP }
};
